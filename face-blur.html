<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Face Blur Tool — Fixed</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css" rel="stylesheet">

  <style>
    body { padding:24px; background:#f7f9fc; }
    .tool-card { max-width:1000px; margin:0 auto; }
    #canvasWrap { position:relative; display:inline-block; }
    #previewCanvas { border:1px solid #ddd; background:#fff; max-width:100%; height:auto; display:block; }
    .face-box {
      position:absolute; border:2px dashed rgba(255,0,0,0.7);
      background: rgba(255,0,0,0.12); box-sizing:border-box; cursor:move;
    }
    .face-box .close-btn {
      position:absolute; top:-10px; right:-10px; width:20px; height:20px;
      background:#d9534f; color:#fff; text-align:center; border-radius:50%; line-height:18px;
      cursor:pointer; font-weight:bold;
    }
  </style>
</head>
<body>
<div class="card tool-card shadow-sm">
  <div class="card-body">
    <h4 class="card-title">Face Blur Tool — Fixed</h4>
    <p class="small text-muted">Uploads image → detect faces on canvas → blur all faces → draggable/resizable boxes → download.</p>

    <div class="form-row align-items-center mb-2">
      <div class="col-sm-5 mb-2"><input id="imageInput" type="file" accept="image/*" class="form-control-file"></div>
      <div class="col-sm-4 mb-2">
        <button id="detectBtn" class="btn btn-primary btn-block" disabled>
          <span id="detectBtnText">Detect Faces</span>
        </button>
      </div>
      <div class="col-sm-3 mb-2 text-right">
        <button id="downloadBtn" class="btn btn-success" disabled>Download PNG</button>
      </div>
    </div>

    <label>Blur radius: <span id="radiusValue">12</span> px</label>
    <input id="blurRange" type="range" min="0" max="80" value="12" class="custom-range mb-3">

    <div id="canvasWrap">
      <canvas id="previewCanvas"></canvas>
    </div>

    <p id="status" class="text-muted mt-3 small">Loading models...</p>
  </div>
</div>

<!-- libs -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>

<!-- face-api and StackBlur (optional) -->
<script src="https://unpkg.com/face-api.js@0.22.2/dist/face-api.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stackblur-canvas/2.2.0/stackblur.min.js"></script>

<script>
(async function(){
  // Configuration
  const MODEL_URL = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';
  const inputSize = 320;           // smaller = faster, larger = more accurate
  const scoreThreshold = 0.3;      // lower = detect more faces (can increase false positives)

  const canvas = document.getElementById('previewCanvas');
  const ctx = canvas.getContext('2d');
  const $imageInput = $('#imageInput');
  const $detectBtn = $('#detectBtn');
  const $detectText = $('#detectBtnText');
  const $downloadBtn = $('#downloadBtn');
  const $blurRange = $('#blurRange');
  const $radiusValue = $('#radiusValue');
  const $status = $('#status');
  const $canvasWrap = $('#canvasWrap');

  let originalImage = null;
  let blurRadius = parseInt($blurRange.val(),10);
  let faceRects = []; // in canvas pixel coordinates

  // Utility: Safe blur function with fallbacks
  function applyBlurRegion(canvasEl, x, y, w, h, radius) {
    // prefer stackBlurCanvasRGBA global function (older builds)
    try {
      if (typeof stackBlurCanvasRGBA === 'function') {
        // some versions accept canvas id string or canvas element; try both safely
        try { stackBlurCanvasRGBA(canvasEl, x, y, w, h, radius); return; } catch(e){}
        try { stackBlurCanvasRGBA(canvasEl.id || 'previewCanvas', x, y, w, h, radius); return; } catch(e){}
      }
      // prefer StackBlur.canvasRGBA API
      if (typeof StackBlur !== 'undefined' && typeof StackBlur.canvasRGBA === 'function') {
        StackBlur.canvasRGBA(canvasEl, x, y, w, h, radius);
        return;
      }
    } catch(e) {
      console.warn('StackBlur call failed, falling back to scaled blur', e);
    }

    // Fallback: scale-down/scale-up trick (fast, not perfect)
    try {
      // clamp box inside canvas
      x = Math.max(0, Math.floor(x));
      y = Math.max(0, Math.floor(y));
      w = Math.max(1, Math.floor(Math.min(w, canvasEl.width - x)));
      h = Math.max(1, Math.floor(Math.min(h, canvasEl.height - y)));
      if (w <= 0 || h <= 0) return;

      // create temp canvas
      const tmp = document.createElement('canvas');
      const tmpCtx = tmp.getContext('2d');

      // amount of downscale depends on radius; larger radius = more downscale
      const scale = Math.max(1, Math.min(16, Math.round(radius / 6) + 1));
      tmp.width = Math.max(1, Math.floor(w / scale));
      tmp.height = Math.max(1, Math.floor(h / scale));

      // draw region to temp small canvas
      tmpCtx.drawImage(canvasEl, x, y, w, h, 0, 0, tmp.width, tmp.height);
      // stretch it back (this creates a blur-like effect)
      ctx.drawImage(tmp, 0, 0, tmp.width, tmp.height, x, y, w, h);
    } catch (e) {
      console.error('fallback blur failed', e);
    }
  }

  // Apply blur for all current rectangles
  function applyAllBlur() {
    if (!originalImage) return;
    // redraw original
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
    // for each face rect, blur that area
    faceRects.forEach(r => {
      applyBlurRegion(canvas, r.x, r.y, r.w, r.h, blurRadius);
    });
  }

  // set canvas to image size but constrain CSS display width
  function setCanvasSize(img) {
    const maxDisplayWidth = 900;
    const scale = img.width > maxDisplayWidth ? (maxDisplayWidth / img.width) : 1;
    canvas.width = img.width;
    canvas.height = img.height;
    canvas.style.width = Math.round(img.width * scale) + 'px';
    canvas.style.height = Math.round(img.height * scale) + 'px';
  }

  // Load face-api models
  async function loadModels(){
    $status.text('Loading face detection model...');
    try {
      await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
      $status.text('Models loaded. Upload an image.');
      $detectBtn.prop('disabled', false);
    } catch (e) {
      console.error('Model load error', e);
      $status.html('Failed to load models from GitHub (CORS or network). Download the models and host them locally or check console.');
      $detectBtn.prop('disabled', true);
    }
  }

  // When user selects image
  $imageInput.on('change', function(e){
    const f = this.files && this.files[0];
    if (!f) return;
    const img = new Image();
    // ensure no cross-origin taint for local files
    img.onload = function(){
      originalImage = img;
      setCanvasSize(img);
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      faceRects = [];
      $canvasWrap.find('.face-box').remove();
      $status.text('Image loaded — click Detect Faces.');
      $downloadBtn.prop('disabled', true);
    };
    img.onerror = function(){ $status.text('Failed to load image.'); };
    img.src = URL.createObjectURL(f);
  });

  // Detect faces (run on canvas to match the actual pixels)
  $detectBtn.on('click', async function(){
    if (!originalImage) return;
    $detectBtn.prop('disabled', true);
    $detectText.html('<span class="spinner-border spinner-border-sm"></span> Detecting...');
    $status.text('Detecting faces on canvas...');
    try {
      // Draw the image to canvas first (ensure detection runs on canvas)
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

      // configure TinyFaceDetector options
      const options = new faceapi.TinyFaceDetectorOptions({ inputSize, scoreThreshold });

      // run detection on canvas element (more consistent with coordinates)
      const detections = await faceapi.detectAllFaces(canvas, options);

      faceRects = [];
      $canvasWrap.find('.face-box').remove();

      if (!detections || detections.length === 0) {
        $status.text('No faces detected. Try a different image or increase image resolution.');
        $detectText.text('Detect Faces');
        $detectBtn.prop('disabled', false);
        return;
      }

      // convert detections (face-api box coords are in px relative to the source)
      detections.forEach(det => {
        const box = det.box;
        // ensure integer coordinates and clamp inside canvas
        const x = Math.max(0, Math.floor(box.x));
        const y = Math.max(0, Math.floor(box.y));
        const w = Math.max(2, Math.floor(Math.min(box.width, canvas.width - x)));
        const h = Math.max(2, Math.floor(Math.min(box.height, canvas.height - y)));
        faceRects.push({ x, y, w, h });
      });

      $status.text(`${faceRects.length} face(s) detected.`);
      // draw draggable/resizable boxes (in displayed CSS coordinate space)
      drawBoxesFromRects();
      // apply blur for all
      applyAllBlur();
      $downloadBtn.prop('disabled', false);
    } catch (e) {
      console.error('Detection error', e);
      $status.text('Face detection error — see console.');
    } finally {
      $detectText.text('Detect Faces');
      $detectBtn.prop('disabled', false);
    }
  });

  // Draw overlay boxes based on faceRects (convert to CSS coords)
  function drawBoxesFromRects() {
    $canvasWrap.find('.face-box').remove();
    const cssScaleX = canvas.clientWidth / canvas.width;
    const cssScaleY = canvas.clientHeight / canvas.height;

    faceRects.forEach((r, idx) => {
      // create box element
      const $box = $('<div class="face-box"></div>').attr('data-idx', idx)
        .css({
          left: (r.x * cssScaleX) + 'px',
          top: (r.y * cssScaleY) + 'px',
          width: (r.w * cssScaleX) + 'px',
          height: (r.h * cssScaleY) + 'px'
        });
      const $close = $('<div class="close-btn">&times;</div>');
      $box.append($close);
      $canvasWrap.append($box);

      // make draggable/resizable within canvasWrap
      $box.draggable({ containment: 'parent', stop: updateRectsFromBoxes })
          .resizable({ handles: 'n,e,s,w,ne,se,sw,nw', containment: 'parent', stop: updateRectsFromBoxes });

      // close -> remove box and update rects & blur
      $close.on('click', function(){
        $box.remove();
        updateRectsFromBoxes();
      });
    });
  }

  // Update faceRects from current overlay boxes (convert CSS coords back to canvas pixels)
  function updateRectsFromBoxes() {
    const cssScaleX = canvas.width / canvas.clientWidth;
    const cssScaleY = canvas.height / canvas.clientHeight;
    const newRects = [];
    $canvasWrap.find('.face-box').each(function(){
      const $b = $(this);
      const left = parseFloat($b.css('left')) || 0;
      const top = parseFloat($b.css('top')) || 0;
      const w = $b.width();
      const h = $b.height();
      const rx = Math.max(0, Math.floor(left * cssScaleX));
      const ry = Math.max(0, Math.floor(top * cssScaleY));
      const rw = Math.max(2, Math.floor(w * cssScaleX));
      const rh = Math.max(2, Math.floor(h * cssScaleY));
      // clamp
      newRects.push({ x: Math.min(canvas.width-1, rx), y: Math.min(canvas.height-1, ry), w: Math.min(rw, canvas.width - rx), h: Math.min(rh, canvas.height - ry) });
    });
    faceRects = newRects;
    applyAllBlur();
  }

  // Blur radius change
  $blurRange.on('input change', function(){
    blurRadius = parseInt(this.value,10);
    $radiusValue.text(blurRadius);
    applyAllBlur();
  });

  // Download final canvas
  $downloadBtn.on('click', function(){
    const a = document.createElement('a');
    a.href = canvas.toDataURL('image/png');
    a.download = 'face_blurred.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  // On window resize: reposition overlay boxes to match CSS scaling
  $(window).on('resize', function(){
    // reapply positions
    drawBoxesFromRects();
  });

  // Start: load models
  await loadModels();

  // Helpful note: if users complain detection still misses faces, try:
  //  - Increasing `inputSize` to 512 or 720 (more accurate, slower)
  //  - Lowering `scoreThreshold` further (more detections, maybe false positives)
  //  - Using higher-resolution input images (face-api works better with larger inputs)
})();
</script>
</body>
</html>
