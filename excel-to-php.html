<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Universal Data Format Converter</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
  <style>
    body { 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
      padding: 20px 0; 
      min-height: 100vh; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    .main-card { 
      background: white; 
      border-radius: 15px; 
      box-shadow: 0 10px 40px rgba(0,0,0,0.2); 
    }
    pre.code-box {
      background: #1e1e1e;
      color: #00ff9d;
      padding: 15px;
      border-radius: 10px;
      overflow-y: auto;
      max-height: 500px;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: 'Courier New', monospace;
    }
    .loader {
      display: none;
      border: 6px solid #f3f3f3;
      border-top: 6px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin { 100% { transform: rotate(360deg); } }
    .table-responsive {
      max-height: 400px;
      overflow: auto;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    th, td { 
      border: 1px solid #ccc; 
      padding: 8px; 
      text-align: left; 
      font-size: 14px; 
    }
    th { 
      background-color: #667eea; 
      color: white; 
      position: sticky; 
      top: 0; 
      z-index: 10; 
    }
    .section-title { 
      color: #667eea; 
      font-weight: bold; 
      margin: 20px 0 15px 0; 
      font-size: 18px;
    }
    .select-format {
      padding: 10px;
      border: 2px solid #667eea;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      background: white;
      color: #667eea;
      font-weight: 600;
    }
    .select-format:focus {
      outline: none;
      border-color: #764ba2;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    .badge-info {
      display: inline-block;
      background: #667eea;
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 12px;
      margin-top: 5px;
    }
    textarea {
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 12px;
      font-family: 'Courier New', monospace;
    }
    textarea:focus {
      border-color: #667eea;
      outline: none;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    input[type="file"] {
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 8px;
    }
    .btn-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 15px;
    }
  </style>
</head>
<body>
<div class="container mt-5 mb-5">
  <h2 class="text-center mb-4 text-white">üîÑ Universal Data Format Converter</h2>
  
  <div class="main-card p-4">
    
    <!-- Step 1: Upload Your Data -->
    <div class="section-title">üì§ Step 1: Upload Your Data</div>
    
    <!-- Input Format Selection -->
    <div style="margin-bottom: 15px;">
      <label style="color: #667eea; font-weight: 600; margin-bottom: 8px; display: block;">Select Input Format:</label>
      <select id="inputFormatSelect" class="select-format" style="width: 100%; max-width: 300px;">
        <option value="auto">Auto Detect</option>
      </select>
    </div>

    <!-- File Input -->
    <input type="file" id="fileInput" class="form-control" accept=".xls,.xlsx,.csv,.json,.xml,.html,.sql,.tsv,.yaml,.yml">
    <p style="font-size: 12px; color: #999; margin-top: 5px;">Supported: JSON, CSV, TSV, XML, SQL, HTML, YAML, Excel</p>

    <!-- Uploaded File Info -->
    <div id="fileInfo" class="badge-info" style="display: none;">
      üìÑ File: <span id="fileName"></span>
    </div>

    <!-- Text Input -->
    <textarea id="textInput" class="form-control mt-3" rows="6" placeholder="Or paste your data here (JSON, XML, SQL, HTML table, CSV, TSV, YAML)..."></textarea>
    <div style="margin-top: 10px;">
      <button id="parseText" class="btn btn-primary">Parse Pasted Data</button>
    </div>

    <div class="loader" id="loader"></div>

    <!-- Preview Section -->
    <div id="previewSection" style="display:none;">
      <div class="section-title mt-4">üëÄ Step 2: Preview Your Data</div>
      <div id="output" class="table-responsive"></div>
      <div class="text-muted small mt-2">
        Showing <span id="rowCount">0</span> rows
        <span class="badge-info" style="margin-left: 10px;">‚úÖ Data Loaded</span>
      </div>
    </div>

    <!-- Output Format Selection -->
    <div id="formatSection" style="display:none;">
      <div class="section-title mt-4">üéØ Step 3: Choose Output Format</div>
      <label style="color: #667eea; font-weight: 600; margin-bottom: 8px; display: block;">Select output format:</label>
      <select id="formatSelect" class="select-format" style="width: 100%; max-width: 300px;">
        <option value="html_table">HTML Table</option>
        <option value="json">JSON</option>
        <option value="excel">Excel (XLSX)</option>
        <option value="sql_insert">SQL Insert</option>
        
        <option value="csv">CSV</option>
        <option value="tsv">TSV</option>
        <option value="markdown">Markdown</option>
        <option value="xml">XML</option>
        <option value="ascii">ASCII Table</option>
        <option value="mediawiki">MediaWiki</option>
        <option value="yaml">YAML</option>
        <option value="php_array">PHP Array</option>
        <option value="bbcode">BBCode</option>
        <option value="ruby">Ruby</option>
        <option value="restructuredtext">reStructuredText</option>
        <option value="asp">ASP</option>
        <option value="actionscript">ActionScript</option>
        <option value="toml">TOML</option>
        <option value="ini">INI</option>
        <option value="firebase">Firebase JSON</option>
        <option value="qlik">Qlik Script</option>
        <option value="jsonlines">JSON Lines</option>
      </select>
    </div>

    <!-- Output Display -->
    <div id="outputContainer" style="display:none;">
      <div class="section-title mt-4">‚ú® Generated Output</div>
      <pre id="codeOutput" class="code-box"></pre>
      <div class="btn-group">
        <button id="copyBtn" class="btn btn-success">üìã Copy to Clipboard</button>
        <button id="downloadBtn" class="btn btn-primary">üíæ Download File</button>
        <button id="clearBtn" class="btn btn-danger">üóëÔ∏è Clear All</button>
      </div>
    </div>
  </div>
</div>

<script>
$(document).ready(function() {
  let parsedData = [];
  let currentFormat = 'json';
  let selectedInputFormat = 'auto';
  let workbookData = null;

  // Load data from localStorage on page load
  function loadFromStorage() {
    const storedData = localStorage.getItem('converterData');
    const storedFileName = localStorage.getItem('converterFileName');
    
    if (storedData) {
      try {
        parsedData = JSON.parse(storedData);
        if (storedFileName) {
          $('#fileName').text(storedFileName);
          $('#fileInfo').show();
        }
        
        displayData();
      } catch (e) {
        console.log('Could not load stored data');
      }
    }
  }

  // Save data to localStorage
  function saveToStorage() {
    localStorage.setItem('converterData', JSON.stringify(parsedData));
  }

  // Load data on page load
  loadFromStorage();

  // Output format selection - Dropdown
  $('#formatSelect').on('change', function() {
    currentFormat = $(this).val();
    generateOutput(currentFormat);
  });

  // Reset format to first option when data changes
  function resetFormatToDefault() {
    $('#formatSelect').val($('#formatSelect option:first').val());
    currentFormat = $('#formatSelect option:first').val();
  }

  $('#fileInput').on('change', function(e) {
    const file = e.target.files[0];
    if (file) handleFile(file);
  });

  $('#parseText').on('click', function() {
    const text = $('#textInput').val().trim();
    if (text) parseTextData(text);
  });

  function handleFile(file) {
    $('#loader').show();
    const ext = file.name.split('.').pop().toLowerCase();
    
    $('#fileName').text(file.name);
    $('#fileInfo').show();

    const reader = new FileReader();

    reader.onload = function(e) {
      const content = e.target.result;
      
      try {
        if (['xls', 'xlsx'].includes(ext)) {
          parseExcel(content);
        } else if (ext === 'csv') {
          parseCSV(content);
        } else if (ext === 'tsv') {
          parseTSV(content);
        } else if (ext === 'json') {
          parseJSON(content);
        } else if (['yaml', 'yml'].includes(ext)) {
          parseYAML(content);
        } else if (ext === 'xml') {
          parseXML(content);
        } else if (ext === 'html') {
          parseHTML(content);
        } else if (ext === 'sql') {
          parseSQL(content);
        }
        
        // Save to localStorage
        localStorage.setItem('converterFileName', file.name);
        saveToStorage();
      } catch (error) {
        alert('Error parsing file: ' + error.message);
        $('#loader').hide();
      }
    };

    if (['xls', 'xlsx'].includes(ext)) {
      reader.readAsArrayBuffer(file);
    } else {
      reader.readAsText(file);
    }
  }

  function parseExcel(data) {
    try {
      const uint8Array = new Uint8Array(data);
      workbookData = XLSX.read(uint8Array, { type: 'array' });
      const firstSheet = workbookData.Sheets[workbookData.SheetNames[0]];
      parsedData = XLSX.utils.sheet_to_json(firstSheet, { defval: '' });
      displayData();
    } catch (e) {
      alert('Error parsing Excel file: ' + e.message);
      $('#loader').hide();
    }
  }

  function parseCSV(content) {
    try {
      const lines = content.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
      parsedData = [];
      
      for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim()) {
          const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
          const obj = {};
          headers.forEach((h, idx) => obj[h] = values[idx] || '');
          parsedData.push(obj);
        }
      }
      displayData();
    } catch (e) {
      alert('Error parsing CSV: ' + e.message);
      $('#loader').hide();
    }
  }

  function parseTSV(content) {
    try {
      const lines = content.trim().split('\n');
      const headers = lines[0].split('\t').map(h => h.trim());
      parsedData = [];
      
      for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim()) {
          const values = lines[i].split('\t').map(v => v.trim());
          const obj = {};
          headers.forEach((h, idx) => obj[h] = values[idx] || '');
          parsedData.push(obj);
        }
      }
      displayData();
    } catch (e) {
      alert('Error parsing TSV: ' + e.message);
      $('#loader').hide();
    }
  }

  function parseJSON(content) {
    try {
      const data = JSON.parse(content);
      parsedData = Array.isArray(data) ? data : [data];
      displayData();
    } catch (e) {
      alert('Invalid JSON format: ' + e.message);
      $('#loader').hide();
    }
  }

  function parseYAML(content) {
    try {
      const data = jsyaml.load(content);
      parsedData = Array.isArray(data) ? data : [data];
      displayData();
    } catch (e) {
      alert('Invalid YAML format: ' + e.message);
      $('#loader').hide();
    }
  }

  function parseXML(content) {
    try {
      const parser = new DOMParser();
      const xml = parser.parseFromString(content, 'text/xml');
      const rows = xml.getElementsByTagName('row');
      parsedData = [];
      
      for (let row of rows) {
        const obj = {};
        for (let child of row.children) {
          obj[child.tagName] = child.textContent;
        }
        parsedData.push(obj);
      }
      if (parsedData.length === 0) throw new Error('No rows found');
      displayData();
    } catch (e) {
      alert('Error parsing XML: ' + e.message);
      $('#loader').hide();
    }
  }

  function parseHTML(content) {
    try {
      const tempDiv = $('<div>').html(content);
      const table = tempDiv.find('table').first();
      const headers = [];
      
      table.find('thead tr th, thead tr td').each(function() {
        headers.push($(this).text().trim());
      });
      
      parsedData = [];
      table.find('tbody tr, tr').slice(1).each(function() {
        const obj = {};
        $(this).find('td').each(function(idx) {
          obj[headers[idx] || `col_${idx}`] = $(this).text().trim();
        });
        if (Object.keys(obj).length > 0) parsedData.push(obj);
      });
      
      if (parsedData.length === 0) throw new Error('No table data found');
      displayData();
    } catch (e) {
      alert('Error parsing HTML: ' + e.message);
      $('#loader').hide();
    }
  }

  function parseSQL(content) {
    try {
      const regex = /INSERT\s+INTO\s+\w+\s*\((.*?)\)\s*VALUES\s*\((.*?)\)/gi;
      const matches = [...content.matchAll(regex)];
      
      if (matches.length === 0) throw new Error('No valid SQL INSERT statements found');
      
      const headers = matches[0][1].split(',').map(h => h.trim().replace(/[`'"]/g, ''));
      parsedData = [];
      
      matches.forEach(match => {
        const values = match[2].split(',').map(v => v.trim().replace(/^['"]|['"]$/g, ''));
        const obj = {};
        headers.forEach((h, idx) => obj[h] = values[idx] || '');
        parsedData.push(obj);
      });
      displayData();
    } catch (e) {
      alert('Error parsing SQL: ' + e.message);
      $('#loader').hide();
    }
  }

  function parseTextData(text) {
    $('#loader').show();
    
    try {
      if (selectedInputFormat !== 'auto') {
        switch(selectedInputFormat) {
          case 'json': parseJSON(text); break;
          case 'csv': parseCSV(text); break;
          case 'tsv': parseTSV(text); break;
          case 'xml': parseXML(text); break;
          case 'sql': parseSQL(text); break;
          case 'html': parseHTML(text); break;
          case 'yaml': parseYAML(text); break;
          default: parseJSON(text);
        }
      } else {
        if (text.startsWith('{') || text.startsWith('[')) {
          parseJSON(text);
        } else if (text.includes('INSERT INTO')) {
          parseSQL(text);
        } else if (text.includes('<table')) {
          parseHTML(text);
        } else if (text.includes('<?xml') || text.includes('<row>')) {
          parseXML(text);
        } else if (text.includes('\t')) {
          parseTSV(text);
        } else if (text.includes(',')) {
          parseCSV(text);
        } else {
          parseJSON(text);
        }
      }
    } catch (e) {
      alert('Error parsing data: ' + e.message);
      $('#loader').hide();
    }
  }

  function displayData() {
    $('#loader').hide();
    
    if (!parsedData || parsedData.length === 0) {
      alert('No data found');
      return;
    }

    const headers = Object.keys(parsedData[0]);
    let table = '<table class="table table-striped"><thead><tr>';
    headers.forEach(h => table += `<th>${h}</th>`);
    table += '</tr></thead><tbody>';

    parsedData.forEach(row => {
      table += '<tr>';
      headers.forEach(h => table += `<td>${row[h] ?? ''}</td>`);
      table += '</tr>';
    });
    table += '</tbody></table>';

    $('#output').html(table);
    $('#rowCount').text(parsedData.length);
    $('#previewSection').show();
    $('#formatSection').show();
    
    // Reset format to first option (JSON)
    resetFormatToDefault();
    generateOutput(currentFormat);
  }

  function normalizeKey(key) {
    return key.trim().toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
  }

  function escapeString(str) {
    return String(str).replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
  }

  function generateOutput(format) {
    let output = '';
    const normalizedData = parsedData.map(row => {
      const obj = {};
      for (let key in row) {
        obj[normalizeKey(key)] = row[key];
      }
      return obj;
    });

    switch(format) {
      case 'json':
        output = JSON.stringify(parsedData, null, 2);
        break;
      
      case 'sql_insert':
        const tableName = 'tableName';
        const originalKeys = Object.keys(parsedData[0]);
        
        // Create table definition with normalized column names
        output = `CREATE TABLE \`${tableName}\` (\n`;
        originalKeys.forEach((key, idx) => {
          const normalizedKey = normalizeKey(key);
          output += `    \`${normalizedKey}\`\tVARCHAR(512)`;
          if (idx < originalKeys.length - 1) output += ',';
          output += '\n';
        });
        output += ');\n';
        
        // Create insert statements
        parsedData.forEach(row => {
          const normalizedRowKeys = originalKeys.map(k => normalizeKey(k));
          const values = originalKeys.map(k => {
            const val = row[k];
            return `'${escapeString(String(val))}'`;
          });
          output += `INSERT INTO \`${tableName}\` (${normalizedRowKeys.map(k => `\`${k}\``).join(', ')}) VALUES (${values.join(', ')});\n`;
        });
        break;
      
      case 'html_table':
        output = '<table border="1">\n  <thead>\n    <tr>\n';
        Object.keys(parsedData[0]).forEach(h => output += `      <th>${h}</th>\n`);
        output += '    </tr>\n  </thead>\n  <tbody>\n';
        parsedData.forEach(row => {
          output += '    <tr>\n';
          Object.values(row).forEach(v => output += `      <td>${v}</td>\n`);
          output += '    </tr>\n';
        });
        output += '  </tbody>\n</table>';
        break;
      
      case 'csv':
        const csvHeaders = Object.keys(parsedData[0]);
        output = csvHeaders.join(',') + '\n';
        parsedData.forEach(row => {
          output += csvHeaders.map(h => `"${escapeString(String(row[h]))}"` ).join(',') + '\n';
        });
        break;

      case 'tsv':
        const tsvHeaders = Object.keys(parsedData[0]);
        output = tsvHeaders.join('\t') + '\n';
        parsedData.forEach(row => {
          output += tsvHeaders.map(h => String(row[h])).join('\t') + '\n';
        });
        break;
      
      case 'markdown':
        const mdKeys = Object.keys(parsedData[0]);
        output = '| ' + mdKeys.join(' | ') + ' |\n';
        output += '| ' + mdKeys.map(() => '---').join(' | ') + ' |\n';
        parsedData.forEach(row => {
          output += '| ' + mdKeys.map(k => row[k]).join(' | ') + ' |\n';
        });
        break;
      
      case 'xml':
        output = '<?xml version="1.0" encoding="UTF-8"?>\n<data>\n';
        parsedData.forEach(row => {
          output += '  <row>\n';
          Object.entries(row).forEach(([k, v]) => {
            output += `    <${normalizeKey(k)}>${escapeString(v)}</${normalizeKey(k)}>\n`;
          });
          output += '  </row>\n';
        });
        output += '</data>';
        break;
      
      case 'php_array':
        output = "<?php\n$data = array(\n";
        normalizedData.forEach(row => {
          output += "  array(\n";
          Object.entries(row).forEach(([k, v]) => {
            const val = typeof v === 'number' ? v : `'${escapeString(v)}'`;
            output += `    '${k}' => ${val},\n`;
          });
          output += "  ),\n";
        });
        output += ");\n?>";
        break;
      
      case 'yaml':
        output = parsedData.map(row => {
          let yaml = '-\n';
          Object.entries(row).forEach(([k, v]) => {
            yaml += `  ${normalizeKey(k)}: ${JSON.stringify(v)}\n`;
          });
          return yaml;
        }).join('');
        break;
      
      case 'ascii':
        const asciiKeys = Object.keys(parsedData[0]);
        const colWidths = asciiKeys.map(k => Math.max(k.length, ...parsedData.map(r => String(r[k]).length)) + 2);
        const line = '+' + colWidths.map(w => '-'.repeat(w)).join('+') + '+\n';
        output = line;
        output += '|' + asciiKeys.map((k, i) => k.padEnd(colWidths[i])).join('|') + '|\n';
        output += line;
        parsedData.forEach(row => {
          output += '|' + asciiKeys.map((k, i) => String(row[k] ?? '').padEnd(colWidths[i])).join('|') + '|\n';
        });
        output += line;
        break;
      
      case 'mediawiki':
        output = '{| class="wikitable"\n|-\n';
        Object.keys(parsedData[0]).forEach(h => output += `! ${h}\n`);
        parsedData.forEach(row => {
          output += '|-\n';
          Object.values(row).forEach(v => output += `| ${v}\n`);
        });
        output += '|}';
        break;
      
      case 'bbcode':
        output = '[table]\n[tr]';
        Object.keys(parsedData[0]).forEach(h => output += `[th]${h}[/th]`);
        output += '[/tr]\n';
        parsedData.forEach(row => {
          output += '[tr]';
          Object.values(row).forEach(v => output += `[td]${v}[/td]`);
          output += '[/tr]\n';
        });
        output += '[/table]';
        break;
      
      case 'ruby':
        output = "data = [\n";
        normalizedData.forEach(row => {
          output += "  {\n";
          Object.entries(row).forEach(([k, v]) => {
            const val = typeof v === 'number' ? v : `'${escapeString(v)}'`;
            output += `    '${k}' => ${val},\n`;
          });
          output += "  },\n";
        });
        output += "]";
        break;
      
      case 'restructuredtext':
        const rstKeys = Object.keys(parsedData[0]);
        const rstWidths = rstKeys.map(k => Math.max(k.length, ...parsedData.map(r => String(r[k] ?? '').length)));
        const rstLine = rstWidths.map(w => '='.repeat(w)).join(' ') + '\n';
        output = rstLine;
        output += rstKeys.map((k, i) => k.padEnd(rstWidths[i])).join(' ') + '\n';
        output += rstLine;
        parsedData.forEach(row => {
          output += rstKeys.map((k, i) => String(row[k] ?? '').padEnd(rstWidths[i])).join(' ') + '\n';
        });
        output += rstLine;
        break;
      
      case 'asp':
        output = "<%\nDim data\ndata = Array( _\n";
        normalizedData.forEach((row, idx) => {
          output += "  Array(";
          output += Object.values(row).map(v => 
            typeof v === 'number' ? v : `"${escapeString(v)}"`
          ).join(', ');
          output += ')' + (idx < normalizedData.length - 1 ? ', _\n' : '\n');
        });
        output += ")\n%>";
        break;
      
      case 'actionscript':
        output = "var data:Array = [\n";
        normalizedData.forEach(row => {
          output += "  {\n";
          Object.entries(row).forEach(([k, v]) => {
            const val = typeof v === 'number' ? v : `"${escapeString(v)}"`;
            output += `    ${k}: ${val},\n`;
          });
          output += "  },\n";
        });
        output += "];";
        break;
      
      case 'toml':
        parsedData.forEach((row, idx) => {
          output += `[[data]]\n`;
          Object.entries(row).forEach(([k, v]) => {
            const val = typeof v === 'number' ? v : `"${escapeString(v)}"`;
            output += `${normalizeKey(k)} = ${val}\n`;
          });
          output += '\n';
        });
        break;
      
      case 'ini':
        parsedData.forEach((row, idx) => {
          output += `[row_${idx}]\n`;
          Object.entries(row).forEach(([k, v]) => {
            output += `${normalizeKey(k)}=${v}\n`;
          });
          output += '\n';
        });
        break;
      
      case 'firebase':
        const firebaseData = {};
        parsedData.forEach((row, idx) => {
          firebaseData[`item_${idx}`] = row;
        });
        output = JSON.stringify(firebaseData, null, 2);
        break;
      
      case 'qlik':
        output = "LOAD * INLINE [\n";
        const qlikKeys = Object.keys(parsedData[0]);
        output += qlikKeys.join(', ') + '\n';
        parsedData.forEach(row => {
          output += qlikKeys.map(k => row[k]).join(', ') + '\n';
        });
        output += "];";
        break;
      
      case 'jsonlines':
        output = parsedData.map(row => JSON.stringify(row)).join('\n');
        break;
      
      case 'excel':
        output = 'Excel export requires download - click the Download button';
        break;
    }

    $('#codeOutput').text(output);
    $('#outputContainer').show();
  }

  $('#copyBtn').on('click', function() {
    navigator.clipboard.writeText($('#codeOutput').text()).then(() => {
      const btn = $(this);
      const originalText = btn.text();
      btn.text('‚úÖ Copied!');
      setTimeout(() => btn.text(originalText), 2000);
    }).catch(() => {
      alert('Failed to copy to clipboard');
    });
  });

  $('#downloadBtn').on('click', function() {
    const extensions = {
      json: 'json', sql_insert: 'sql', html_table: 'html', csv: 'csv', tsv: 'tsv',
      markdown: 'md', xml: 'xml', php_array: 'php', yaml: 'yaml',
      ascii: 'txt', mediawiki: 'txt', bbcode: 'txt', ruby: 'rb',
      restructuredtext: 'rst', asp: 'asp', actionscript: 'as',
      toml: 'toml', ini: 'ini', firebase: 'json', qlik: 'qvs',
      jsonlines: 'jsonl'
    };

    if (currentFormat === 'excel') {
      try {
        const ws = XLSX.utils.json_to_sheet(parsedData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Data');
        XLSX.writeFile(wb, 'data.xlsx');
      } catch (e) {
        alert('Error generating Excel file: ' + e.message);
      }
    } else {
      const content = $('#codeOutput').text();
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `data.${extensions[currentFormat] || 'txt'}`;
      link.click();
      URL.revokeObjectURL(link.href);
    }
  });

  $('#clearBtn').on('click', function() {
    parsedData = [];
    workbookData = null;
    currentFormat = 'json';
    selectedInputFormat = 'auto';
    
    // Clear localStorage
    localStorage.removeItem('converterData');
    localStorage.removeItem('converterFileName');
    
    $('#output').empty();
    $('#codeOutput').empty();
    $('#previewSection').hide();
    $('#formatSection').hide();
    $('#outputContainer').hide();
    $('#textInput').val('');
    $('#fileInput').val('');
    $('#fileInfo').hide();
    $('#fileName').text('');
    
    $('#formatSelect').val('json');
    $('#inputFormatSelect').val('auto');
  });
});
</script>
</body>
</html>
